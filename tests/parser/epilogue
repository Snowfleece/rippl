%%

let op_to_str s =
    match s with
    (* Boolean Operators *)
    | Or -> "or"
    | And -> "and"
    | Not -> "not"
    | Eq -> "=="
    | EqF -> "==."
    | Neq -> "!="
    | NeqF -> "!=."
    | Less -> "<"
    | LessF -> "<."
    | Greater -> ">"
    | GreaterF -> ">."
    | Leq -> "<="
    | LeqF -> "<=."
    | Geq -> ">="
    | GeqF -> ">=."
    (* Math Operations *)
    | Add -> "+"
    | Sub -> "-"
    | Mult -> "*"
    | Div -> "/"
    | AddF -> "+."
    | SubF -> "-."
    | MultF -> "*."
    | DivF -> "/."
    | Pow -> "^"
    | PowF -> "^."
    | Neg -> "neg"
    (* List Operations *)
    | Cons -> "cons"
    | Cat -> "cat"
    | Head -> "head"
    | Tail -> "tail"
    | Len -> "len"
    | _ -> "other"

let char_list_to_str cl =
    match cl with
    | [] -> ""
    | [Ast.CharLit c] -> String.make 1 c
    | charlist -> let convert x = match x with 
        | Ast.CharLit c -> c 
        | _ -> 'F'
        in List.fold_left (^) "" (List.map (String.make 1) (List.map convert charlist))

let rec ast_to_str exp =
    match exp with
    | Ite(e1,e2,e3) -> "Ite(" ^ (ast_to_str e1) ^ "," ^ (ast_to_str e2) ^ "," ^ (ast_to_str e3) ^ ")"
    | Let(e1,e2) -> "Let(" ^ (ast_to_str e1) ^ "," ^ (ast_to_str e2) ^ ")"
    | Lambda(e1,e2) -> "Lambda(" ^ (ast_to_str e1) ^ "," ^ (ast_to_str e2) ^ ")"
    | App( App(op, arg1), arg2) -> "App(App(" ^ op_to_str op ^ "," ^ (ast_to_str arg1) ^ ")," ^ (ast_to_str arg2) ^ ")"
    | App(op, e) -> "App(" ^ (op_to_str op) ^ "," ^ (ast_to_str e) ^ ")"
    | Var(s) -> "Var(" ^ s ^ ")"

    (* Lists skipped for now *)

    | Assign(e1, e2) -> "Assign(" ^ (ast_to_str e1) ^ "," ^ (ast_to_str e2) ^ ")"
    | BoolLit(b) -> string_of_bool b
    | CharLit(c) -> String.make 1 c
    | ListLit(char_list) -> "\"" ^ (char_list_to_str char_list) ^ "\""
    | IntLit n -> string_of_int n
    | FloatLit f -> string_of_float f
    | _ -> ""


let _ =
    let lexbuf = Lexing.from_channel stdin in
    let decl = Parser.program Scanner.token lexbuf in
    let ast_str =
    match decl with
        | [Vdef(s, expr)] -> s ^ " = " ^ (ast_to_str expr)
        | h::t -> "not implemented"
        | [] -> "not implemented"
    in print_endline ast_str
