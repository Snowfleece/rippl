%%

let op_to_str s =
    match s with
    (* Boolean Operators *)
    | Or -> "or"
    | And -> "and"
    | Not -> "not"
    | Eq -> "=="
    | EqF -> "==."
    | Neq -> "!="
    | NeqF -> "!=."
    | Less -> "<"
    | LessF -> "<."
    | Greater -> ">"
    | GreaterF -> ">."
    | Leq -> "<="
    | LeqF -> "<=."
    | Geq -> ">="
    | GeqF -> ">=."
    (* Math Operations *)
    | Add -> "+"
    | Sub -> "-"
    | Mult -> "*"
    | Div -> "/"
    | AddF -> "+."
    | SubF -> "-."
    | MultF -> "*."
    | DivF -> "/."
    | Pow -> "^"
    | PowF -> "^."
    | Neg -> "neg"
    (* List Operations *)
    | Cons -> "cons"
    | Cat -> "cat"
    | Head -> "head"
    | Tail -> "tail"
    | Len -> "len"
    | _ -> "other"


let char_list_to_str cl =
    match cl with
    | [] -> ""
    | [Ast.CharLit c] -> String.make 1 c
    | charlist -> let convert x = match x with 
        | Ast.CharLit c -> c 
        | _ -> 'F'
        in List.fold_left (^) "" (List.map (String.make 1) (List.map convert charlist))

let rec ast_to_str exp =
    match exp with
    | Ite(e1,e2,e3) -> "IF " ^ (ast_to_str e1) ^ " THEN " ^ (ast_to_str e2) ^ " ELSE " ^ (ast_to_str e3)
    | Let(e1,e2) -> "LET " ^ (ast_to_str e1) ^ " IN " ^ (ast_to_str e2)
    | Lambda(e1,e2) -> "LAMBDA " ^ (ast_to_str e1) ^ " -> " ^ (ast_to_str e2)
    | App( App(op, arg1), arg2) -> "App( App( " ^ op_to_str op ^ " , " ^ (ast_to_str arg1) ^ " ) , " ^ (ast_to_str arg2) ^ " )"
    | App(op, e) -> "App( " ^ (op_to_str op) ^ " , " ^ (ast_to_str e) ^ " )"
    | Var(s) -> s

    (* Lists skipped for now *)

    | Assign(e1, e2) -> "Assign( " ^ (ast_to_str e1) ^ " , " ^ (ast_to_str e2) ^ " )"
    | BoolLit(b) -> string_of_bool b
    | CharLit(c) -> String.make 1 c
    | ListLit(char_list) -> char_list_to_str char_list
    | IntLit n -> string_of_int n
    | FloatLit f -> string_of_float f
    | _ -> ""


let _ =
    let lexbuf = Lexing.from_channel stdin in
    let expr = Parser.entry Scanner.token lexbuf in
    let ast_str = ast_to_str expr in
    print_endline ast_str
