normSquared :: Float -> Float -> Float
normSquared = \a -> \b -> a^2 + b^2

encode :: Int -> Char
encode = \count ->
	if count == 0
		then 'D'
		else if count < 10
			then 'C'
			else if count < 50
				then 'B'
				else if count < 200
					then 'A'
					else ' '

iterateJulia :: Int -> Float -> Float -> Float -> Float -> Char
iterateJulia = \c -> \b_z -> \a_z -> \b -> \a ->
	if c > 200 
		then ' '
		else if	normSquared (a_z*a_z - b_z*b_z + a) (2.0*a_z*b_z + b) > 4.0
			then encode c
			else iterateJulia (c+1) (2.0*a_z*b_z + b) (a_z*a_z - b_z*b_z + a) b a 

-- complex range 	[-1.0, 1.0] y axis
-- real range 		[-2.0, 1.0] x axis

everyOther :: [a] -> [a]
everyOther = \list ->
	if length list == 0
		then []
		else if length list == 1
			then [head list]
			else (head list):(everyOther (tail (tail list)))

iterateComplex :: Float -> Float -> [Char]
iterateComplex = \b0 -> \a0 ->
	let range = map (/ 100) [-100..100] in
	let complexRange = everyOther range in
	let iterComplexRec = \r ->
		if length r == 0
			then " "
			else (iterateReal b0 a0 (head r)) ++ (iterComplexRec (tail r)) in iterComplexRec complexRange

iterateReal :: Float -> Float -> Float -> [Char]
iterateReal = \b0 -> \a0 -> \b ->
	let range = map (/ 100) [-200..100] in
	let realRange = everyOther range in
	let realLine = map (iterateJulia 0 b0 a0 b) realRange in
	realLine ++ "\n"

julia :: Float -> Float -> [Char]
julia = \b0 -> \a0 -> iterateComplex b0 a0

main = do
	putStrLn $ julia 0.26 0
