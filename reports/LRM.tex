\documentclass[5pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{multicol}
\usepackage[rgb,dvipsnames]{xcolor}
\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{pxfonts}
\usepackage{tabto}
\usepackage{listings}
\usepackage[margin=1.8in]{geometry}
\addtolength{\topmargin}{-.5in}
\addtolength{\textheight}{0.5in}

\definecolor{mygrey}{rgb}{0.5,0.5,0.5}
\lstdefinelanguage{rippl}{
    language=Python,
	keywords={ over, let, in, fun, if, then, else, and, or, not, true, false, 
	pre, head, tail, int, bool, float, char, cons},
}
\lstset{
         numbers=left,
         language=rippl,
         showstringspaces=false,
         firstnumber=1,
  		 numberfirstline=true,
  		 numberstyle=\ttfamily\scriptsize,
 		 xleftmargin=5.0ex,
         basicstyle=\ttfamily\small,
         tabsize=4,
         commentstyle=\color{mygrey},
         keywordstyle=\bfseries
 }

\title{Rippl: Recursively Inferred Pure functional Pythonic Language}
\author{Da Hua Chen (Riddler), Hollis Lehv (Gallbladder),\\Amanda Liu (Language Yoda), Hans Montero (Prime Minister)}
\date{}
\begin{document}

\maketitle
\section{Overview}

\subsection{Introduction}
Rippl is a functional language that leverages the safety and elegance of pure languages like Haskell with the intuitive syntax of Python. With list comprehensions, a strong static type system implementing Hindley-Milner style inference, higher-order functions, and simple syntax, Rippl is a powerful computational language with strong support for list-oriented calculations as well as support for association of items of different types in the form of tuples. Rippl will be an appropriate introduction for users without prior functional programming experience who want to effectively and safely perform complex mathematical calculations.


\subsection{Motivation}
Functional programming languages generally support powerful and concise language constructs such as higher-order functions, partial application, recursion, and immutability, but at the cost of hard-to-read syntax that is not friendly to unfamiliar users. High-level imperative languages like Python support a highly human-readable syntax but allow mutable state which can lead to bugs and a weak, dynamic typing system which pushes errors to runtime. Rippl has many of the paradigmatic features of functional programming, such as higher-order functions, recursion, and lazy evaluation. Its syntax is intended to make programs written in a functional style more readable and intuitive to users who are more accustomed  to other programming paradigms.

\pagebreak

\section{Type System}
Rippl has proper (primitive) types, higher-order types, and arrow types.

\subsection{Proper Types}
The proper types in Rippl are $\texttt{int}$, $\texttt{float}$, $\texttt{bool}$, and $\texttt{char}$.
\subsubsection*{\texttt{int} --- Integers}
\texttt{int} is the signed integer type. An integer literal may be preceded by a unary minus (\texttt{-}) to denote a negative integer. Unary plus (\texttt{+}) is not supported. Integers are written in base 10 (decimal) and cannot be written in other bases (e.g. binary, octal, hexadecimal).

\subsubsection*{\texttt{float} --- Floating-point Numbers}
\texttt{float} is the floating-point numerical type. Float literals must be written with a decimal point and at least one digit to the left and right of the decimal point (e.g. \texttt{-4.2}, \texttt{10.0}). This format was chosen to avoid ambiguity with integer literals when used with the list range operator (\dots). Numbers not written in this format, e.g. \texttt{6.}, \texttt{.53}, and \texttt{-.0}, are not valid floats. Floating-point numbers written in scientific notation, e.g. \texttt{1.37e15}, are also not supported.
\subsubsection*{\texttt{bool} --- Booleans}
\texttt{bool} is the Boolean type. There are two Boolean literals, \texttt{true} and \texttt{false}.
\subsubsection*{\texttt{char} --- Characters}
\texttt{char} is the character type. A character literal is written as a single character in single quotes e.g. \texttt{\sq A\sq}, \texttt{\sq !\sq}, \texttt{\sq+\sq}. Special characters, such as the newline character \sq\texttt{\string\n}\sq, are escaped with a backslash ($\backslash$).

\subsubsection{Summary of Proper Types}
\begin{multicols}{3}
$Type$ \\
\hspace*{5mm} \texttt{int} \\
\hspace*{5mm} \texttt{float} \\
\hspace*{5mm} \texttt{bool} \\
\hspace*{5mm} \texttt{char} \\
\columnbreak \\
$Size$ \\
4 bytes \\
8 bytes \\
1 byte \\
1 byte \\
\columnbreak \\
$Examples$ \\
\texttt{0, 37, -2, 2019} \\
\texttt{0.0, -6.9, 3.1415926} \\
\texttt{true, false} \\
\texttt{\sq\#\sq, \sq x\sq, \sq D\sq, \sq \string\n \sq }  \\
\end{multicols}

\subsection{Higher-Order Types}
The higher-order types in Rippl are lists and tuples.
\subsubsection{Lists}
Lists are a first-order type (the type of a list is defined by the type of its elements), and all elements of a list must have the same type. Lists are parametrically polymorphic in the type of its elements. This means that a function that acts on lists need not concern itself with the type of the elements of the list. Such a function is said to be parameterized by the type of the elements in the list. All list operators in Rippl (see section on operators) act on lists of arbitrary type. \\\\
Strings are handled and represented internally as lists of \texttt{char}, but
string literals may be written in the usual sugared representation with double quotes e.g. \texttt{"Hello, World!"}.\\\\
Lists as well as list types are delimited by brackets, and list elements are separated by commas (e.g. $\texttt{[0,3,1]}$, which has type \texttt{[int]}, $\texttt{[\sq R\sq,\sq i\sq,\sq p\sq,\sq p\sq,\sq l\sq]}\Leftrightarrow \texttt{"Rippl"}$, which has type $\texttt{[char]}$).

\subsubsection{Tuples}
Tuples are also a first-order type, parametrically polymorphic in the types of its elements. A tuple must contain exactly two elements, but each of them can be of any type. Tuples as well as their types are delimited by parentheses, and elements are separated by commas (e.g. \texttt{("PLT",4118)}, which has type \texttt{([char],int)}).

\subsubsection{\texttt{maybe} type}
Hey I just met you and this is crazy. But here's my number, so call me \texttt{maybe}.

\subsection{Arrow Types}
An arrow type is a sequence of types separated by an arrow (\texttt{->}) and represents the type of a function or operator. The last type in an arrow type is the return type, and the previous types in the sequence are the input types. For example, the integer addition operator $\texttt{(+)}$ takes two integer inputs and returns an integer output, so it has type $\texttt{int -> int -> int}$. Functions, function compositions, and partially applied functions can all be expressed as arrow types.

\subsection{Type Annotations and Inference}
Rippl supports type inference through an implementation of the Hindley-Milner type inference system over the core syntactic language constructs of lambda abstractions, let-bindings, application, and variable names, as well as the additional language construct of if-then-else expressions. \\

By performing type inference in an environment where literals and language native operators (see section FILLNUMLATER) are bootstrapped  with a particular type, types of expressions can be inferred and checked in a complete and decidable manner. These types signatures may be concrete types like the ones below.

\begin{lstlisting}[language=rippl]
sum_ints :: int -> int -> int
\end{lstlisting}
\begin{lstlisting}[language=rippl]
count_chars :: [char] -> int
\end{lstlisting}
\begin{lstlisting}[language=rippl]
is_mutually_prime :: int -> int -> bool
\end{lstlisting}

However, these inferred types may also be parametrically polymorphic. These polymorphic types are represented as type variables like the ones below. \\

\begin{lstlisting}[language=rippl]
identity :: a -> a
\end{lstlisting}
\begin{lstlisting}[language=rippl]
len :: [a] -> int
\end{lstlisting}
\begin{lstlisting}[language=rippl]
empty_list :: [a]
\end{lstlisting}
\begin{lstlisting}[language=rippl]
map :: a -> b -> [a] -> [b]
\end{lstlisting}

Rippl also allows programmers to provide their own type annotations for function definitions. This is done using the Haskell-like syntax shown in the previous examples, that involves specifying the variable name followed its full curried type signature, separated by a double colon "\texttt{::}". Type annotations are optional, but when they are provided type-checking is performed to make sure the user-annotated types are at most as generalized as the inferred type. In other words, the type annotation must be a subtype of the inferred type. \\

The following function definition is an example of how an inferred type and annotated type can type-check directly if they are equal. \\

\begin{lstlisting}[language=rippl]
succ :: int -> int
succ n = n +1       # inferred type is int -> int
\end{lstlisting}

The following type annotation would yield a typing error since the inferred type and annotated type contradict each other. This is due to the built in type of the integer addition and division operators and the fact that Rippl doesn't perform any implicit type promotions. \\

\begin{lstlisting}[language=rippl]
avg :: int -> int -> float
avg x y = (x + y) / 2   # inferred type is int -> int -> int
\end{lstlisting}

The following function definition and annotation also type-check correctly since the inferred type that is parametrically polymorphic with type variable \texttt{a} can be properly concretized by substitution \texttt{a} with the concrete type \texttt{int} to match the user-annotated type. \\

\begin{lstlisting}[language=rippl]
nest_int_list :: [int] -> [[int]]
nest_int_list l = l cons []     # inferred type is [a] -> [[a]]
\end{lstlisting}

The following function definition is an example of a type annotation that won't type-check with the inferred type. The inferred type enforces that the return type of \texttt{identity} be the same as its argument, so it's polymorphic in one type variable \texttt{a}. This is a stronger type restriction than the annotated type which states that the function is polymorphic and may return a type different than that of its argument. Since the annotated type must be a subtype of the inferred type, this would yield a type error. \\

\begin{lstlisting}[language=rippl]
identity :: a -> b
identity x = x          # inferred type is a -> a
\end{lstlisting}

\section{Language Features}
Rippl sets out to provide a clean and intuitive functional programming experience like no other language can. As such, it is inspired by some of the best features of some of the best languages out there.
\subsection{Clean Code}
One of Rippl’s biggest influences is Python, for its simple operator syntax.
Keywords like \texttt{and}, \texttt{or}, and \texttt{not} make it closer to
natural language and therefore more human-readable. Rippl extends this
user-positive experience to functional operations that in other languages take
the form of symbols or strangely abbreviated words, which obfuscates code. Rippl instead offers descriptive yet concise list operators like \texttt{cons} and
\texttt{cat} and tuple operators like \texttt{first} and \texttt{sec}. Lastly,
list comprehensions receive a fresh look in Rippl, with the introduction of the
\texttt{over} keyword and a more familiar mathematical notation, reminiscent of set builders.
\subsection{Type Inference}
Since Rippl is a statically typed language, it can take advantage of an inferenced type system. Specifically, Rippl implements the Hindley-Milner system, which is the basis for Haskell’s type system. By having language-native operators and literals bootstrapped in the typing context with an explicit type, we are able to infer the type of expressions using Hindley-Milner's core syntactic type inference rules. This type system also allows for parametric polymorphism, meaning the type of an expression may be expressed in terms of type variables and will type check with any expression of a concrete type that matches the type schema. Also like Haskell, Rippl will not require type annotations, but will allow them for type-checking and documentation purposes.
\subsection{First-class Functions}
The use of first-class functions encompasses many of the core features of the functional programming paradigm. One such feature is higher-order functions where arguments and return values may be other functions. Currying is another feature that allows us to view functions, function compositions, partially applied functions, and return values all as arrow types. Having functions in a curried arrow-type form allows us to employ partial application tied together with closures, as is idiomatic in functional languages.
\subsection{Lazy Evaluation}
Rippl supports a Haskell-style, non-strict lazy evaluation in which the value of expressions isn’t fully evaluated until it is needed in another expression. This is particularly useful in that Rippl also supports immense list constructions like infinite lists and cycles, which are native to Haskell. Given the infinitely self-referential definition of these structures, they are kept unevaluated until an element is needed for further computation.
\pagebreak
\section{Grammar and Syntax}
\begin{multicols}{2}
\noindent $\mu \ ::= $ \\
\hspace*{10mm} $| \quad \texttt{main } e = e$ \\

\noindent $e \ ::= $ \\
\hspace*{10mm} $| \quad c$ \\
\hspace*{10mm} $| \quad x$ \\
\hspace*{10mm} $| \quad e \ e$ \\
\hspace*{10mm} $| \quad \texttt{fun } x \texttt{ -> } e$ \\
\hspace*{10mm} $| \quad \texttt{let }x = e \texttt{ in } e$ \\
\hspace*{10mm} $| \quad \texttt{if } e \texttt{ then } e \texttt{ else } e$ \\
\hspace*{10mm} $| \quad \gamma$ \\

\noindent $\gamma \ ::= $ \\
\hspace*{10mm} $| \quad \texttt{[}e...\texttt{]}$ \\
\hspace*{10mm} $| \quad \texttt{[}e...e\texttt{]}$ \\
\hspace*{10mm} $| \quad \texttt{[}e \ | \ x \texttt{ over } \gamma, \texttt{]}$ \\
\hspace*{10mm} $| \quad \texttt{[}e \ | \ x \texttt{ over } \gamma, e \texttt{]}$ \\

\noindent $\sigma \ ::= $ \\
\hspace*{10mm} $| \quad \texttt{int}$ \\
\hspace*{10mm} $| \quad \texttt{float}$ \\
\hspace*{10mm} $| \quad \texttt{bool}$ \\
\hspace*{10mm} $| \quad \texttt{char}$ \\

\noindent $\delta \ ::= $ \\
\hspace*{10mm} $| \quad \texttt{[]} $ \\
\hspace*{10mm} $| \quad \texttt{()} $ \\

\noindent $\tau \ ::= $ \\
\hspace*{10mm} $| \quad \sigma $ \\
\hspace*{10mm} $| \quad \delta \ \tau $ \\
\hspace*{10mm} $| \quad \tau \texttt{->} \tau $ \\

\noindent $\theta \ ::= $ \\
\hspace*{10mm} $| \quad x \ :: \  \tau $ \\
\columnbreak \\
$Entrypoint$ \\
main method \\

\noindent $Expressions$ \\
literals \\
variables \\
application \\
lambda abstraction \\
let binding \\
if-then-else \\
list comprehension \\

\noindent $List \ Comprehensions$ \\
infinte list \\
ranged list \\
parametric list \\
qualified list \\

\noindent $Proper \ Types$ \\
integer \\
floating point number \\
boolean \\
character \\

\noindent $Higher \ Order \ Type \ Constructors$ \\
list \\
tuple \\

\noindent $Types$ \\
proper type \\
higher order type \\
arrow type \\

\noindent $Type \ Annotations$ \\
type annotations \\
\end{multicols}

\noindent \texttt{\# Single line comments will be marked by a pound sign} \\

\noindent \texttt{\{- Multiline comments will be delimited by curly braces and dashes. } \\
\texttt{ \hspace*{3mm} Much like in a Haskell-like program -\}} \\

\newpage 

\section{Operators}
\subsection{Numeric}
Our numeric or $num$ type represents the typeclass that encompasses $int$ and
$float$. This use of this typeclass is mainly meant to aid in inference and
protect the user from explicit typecasting. $int$, $float$, and $num$ types may
be used explicitly in user-annotated types. However, numeric literals are
inferred to be of type $int$ unless the literal is explicitly written with a "."
decimal point and inferred to be of type $float$.
\begin{multicols}{3}
\noindent $Operator$ \\
\hspace*{5mm} + \\
\hspace*{5mm} - \\
\hspace*{5mm} * \\
\hspace*{5mm} / \\
\hspace*{5mm} \% \\
\hspace*{5mm} \^ \\
\hspace*{5mm} $>$ \\
\hspace*{5mm} $>=$ \\
\hspace*{5mm} $<$ \\
\hspace*{5mm} $<=$ \\
\hspace*{5mm} == \\
\hspace*{5mm} != \\
\columnbreak \\
\noindent $Type$ \\
$num \ \rightarrow \ num \ \rightarrow \ num $ \\
$num \ \rightarrow \ num \ \rightarrow \ num $ \\
$num \ \rightarrow \ num \ \rightarrow \ num $ \\
$num \ \rightarrow \ num \ \rightarrow \ num $ \\
$int \quad \rightarrow \ int \quad \rightarrow \ int $ \\
$num \ \rightarrow \ num \ \rightarrow \ num $ \\
$num \ \rightarrow \ num \ \rightarrow \ bool $ \\
$num \ \rightarrow \ num \ \rightarrow \ bool $ \\
$num \ \rightarrow \ num \ \rightarrow \ bool $ \\
$num \ \rightarrow \ num \ \rightarrow \ bool $ \\
$num \ \rightarrow \ num \ \rightarrow \ bool $ \\
$num \ \rightarrow \ num \ \rightarrow \ bool $ \\
\columnbreak \\
$Function$ \\
addition \\
subtraction \\
multiplication \\
division \\
modulus \\
power \\
greater than \\
greater than or equal \\
less than \\
less than or equal \\
equal \\
not equal \\
\end{multicols}
\subsection{Boolean}
Boolean values are of type $bool$ and consist of the literals \texttt{true} and \texttt{false}. 
\begin{multicols}{3}
\noindent $Operator$ \\
\hspace*{5mm} \texttt{and} \\
\hspace*{5mm} \texttt{or} \\
\hspace*{5mm} \texttt{not} \\
\columnbreak \\
\noindent $Type$ \\
$bool \ \rightarrow \ bool \ \rightarrow \ bool $ \\
$bool \ \rightarrow \ bool \ \rightarrow \ bool $ \\
$bool \ \rightarrow \ bool $ \\
\columnbreak \\
\noindent $Function$ \\
and \\
or \\
negation \\
\end{multicols}
\subsection{Character}
Character literals are delimited by single quotes and are of type \textit{char}. 
Strings are constructed and treated as lists of \textit{char}.
\begin{multicols}{3}
\noindent $Operator$ \\
\hspace*{5mm} == \\
\columnbreak \\
\noindent $Type$ \\
$char \ \rightarrow \ char \ \rightarrow \ bool $ \\
\columnbreak \\
\noindent $Function$ \\
equal \\
\end{multicols}
\pagebreak
\subsection{Lists}
A list is a first order type that is parametrically polymorphic in the type of 
its elements. All elements of a list must be the same type. Strings are handled 
and represented internally as lists of \texttt{char}s, but
literal strings may be written using double quotes. Lists as well as 
list types are delimited with brackets (e.g. \texttt{[int]}, \texttt{[0,3,1]}, \texttt{"Hello"}). 
\begin{multicols}{3}
\noindent $Operator$ \\
\hspace*{5mm} \texttt{cons} \\
\hspace*{5mm} \texttt{head} \\
\hspace*{5mm} \texttt{tail} \\
\hspace*{5mm} \texttt{len} \\
\hspace*{5mm} \texttt{cat} \\
\columnbreak \\
\noindent $Type$ \\
$a \ \rightarrow \ [a] \ \rightarrow \ [a] $ \\
$[a] \ \rightarrow \ a $ \\
$[a] \ \rightarrow \ [a] $ \\
$[a] \ \rightarrow \ int $ \\
$[a] \ \rightarrow \ [a] \ \rightarrow \ [a] $ \\
\columnbreak \\
\noindent $Function$ \\
construct \\
head \\
tail \\
length \\
concatenate \\
\end{multicols}
\subsection{Tuples}
A tuple is a first order type, parametrically polymorphic in the types of its 
elements. A tuple can contain two elements of any type. Tuples as well as their 
types will be delimited by parentheses (e.g. \texttt{("PLT",4118)}, 
\texttt{([char],int)}).
\begin{multicols}{3}
\noindent $Operator$ \\
\hspace*{5mm} \texttt{first} \\
\hspace*{5mm} \texttt{sec} \\
\columnbreak \\
\noindent $Type$ \\
$(a,b) \ \rightarrow \  a$ \\
$(a,b) \ \rightarrow \  b$ \\
\columnbreak \\
\noindent $Function$ \\
first element of tuple \\
second element of tuple \\
\end{multicols}

\section{Entrypoints and IO}
Like all pure functional languages, Rippl ensures that the evaluation of all expressions is free of side effects, or stateful interactions with the outside world. This prohibits the insertion of print statements inside functions that execute as they are evaluated. \\

Also as a pure functional language, Rippl also guarantees that any computation given an argument will always return the same output. This means there can be no assumption of order of evaluation in a program as there is in the imperative paradigm. This prohibits the use of language constructs like \texttt{input} or \texttt{scanf} that read and return a value read from the user with no arguments (save the format-friendly strings present; this is more like a separate print/IO action that a true argument). With no varying argument, the function call in a pure language should return the same value each time which should not be the behavior of an IO operation. \\

Pure functional languages like Haskell by giving all the IO function calls a hidden argument and strings them together as arguments and dependencies to create a proper ordering by using an IO monad. This operation is sugared up into an imperative-looking \texttt{do} construct in their main methods. \\

Like in Haskell, the main method in Rippl is the top-level entrypoint into a program. In order to avoid the use of higher-kinded types like in Haskell, the main method is used such that there is only one input operation allowed and one output operation allowed, strictly evaluated in that order.  \\

User input is represented as the argument to the main function. It can be bound as a named argument that is then used for evaluation of the body of the main function if it requires user input. \\

\begin{lstlisting}[language=rippl]
# this main method takes user input and stores it in `arg`
main arg = ... 
\end{lstlisting}

Otherwise, to signify that nothing is to be read from user input, an underscore takes the place of the first argument (much like the wildcard in Haskell). \\

\begin{lstlisting}[language=rippl]
# this main method takes no user input
main _ = ...    
\end{lstlisting}

The evaluated value of the body of the main function is printed. The "Hello, world!" program would be written as follows in Rippl.

\begin{lstlisting}[language=rippl]
# this prints "Hello, world!" to the terminal
main _ = "Hello, world!"
\end{lstlisting}

If the right-hand side of the main method were a more complex computation expressed in terms of other function definitions provided in the file, the full expression would be evaluated and printed. This means that the main function is also fully polymorphic in terms of its input and output. \\

\begin{lstlisting}[language=rippl]
main :: a -> b
\end{lstlisting}

It might be noted that this construct of IO in a language doesn't allow for a function no to have output (Rippl doesn't have a \texttt{void} value representing a bottom type). However, this design should be reasonable since Rippl currently supports no other output operations so programs would be moot otherwise. \\

\section{List Comprehensions} 
List comprehensions are an elegant and concise way to define and construct a list. They use a well-known mathematical notation to substitute complex list operations like map and filter. \\

Rippl uses lazy evaluation for list comprehensions. This means that only the head of the list is initially fully evaluated and other elements are evaluated when their value is requested. \\
/comments

\begin{lstlisting}[language=rippl]
[1, 2, 3, 18, -1]
\end{lstlisting}


ranged list \\
With ranged lists, we can create a list without specifying every element. Ranges will always have an interval of + 1 and are only allowed for integer lists. 

\begin{lstlisting}[language=rippl]
[18...24] # [18, 19, 20, 21, 22, 23, 24]

['a'...'z'] # not allowed

[1.2...2.7] # no sir, uncountable number of elements
\end{lstlisting}

parametric list \\
Parametric lists allow users to specify a parameter.

\begin{lstlisting}[language=rippl]
[x * 2 | x over [3, 1, 4]] # [6, 2, 8] 

[x | x over [9...12]] # [9, 10, 11, 12]
\end{lstlisting}


qualified list \\
With qualified lists, lists can be filtered by a condition.

\begin{lstlisting}[language=rippl]
[x ^ 2 | x over [1...10], x % 2 == 0] # [4, 16, 36, 64, 100]
\end{lstlisting}


parallel list \\
Parallel list comprehensions are lists comprehensions with multiple parameters.

\begin{lstlisting}[language=rippl]
[x - y - z | x over [10, 1], y over [2, 3], z over [1, 5]] 
    # [7, 3, 6, 2, -2, -6, -3, -7]
    
[x + y | x over [10, 30, 50], y over [10...12], x != y]
    # [20, 21, 22, 40, 41, 42, 60, 61, 62]
\end{lstlisting}

infinite list \\
Thanks to lazy evaluation, Rippl supports infinite lists. 

\begin{lstlisting}[language=rippl]
[3...] # [3, 4, 5, ...] 

[2, 22...24, 7...] # [2, 22, 23, 24, 7, 8, ...]
\end{lstlisting}

\section{Sample Programs}
\subsection{Infinite Sum}
This program returns the sum of the first $n$ positive integers using an 
infinite list.
\begin{lstlisting}[language=rippl]
inf_sum :: int -> int
inf_sum n = let infinity = [1...] in
    let rec_inf_sum x list acc = if x == 0 or (len list) == 0
        then acc
        else rec_inf_sum (x-1) (tail list) ((head list) + acc)
    in rec_inf_sum n infinity 0
\end{lstlisting}
\subsection{Collatz Conjecture}
The Collatz conjecture is a conjecture in mathematics surrounding the iterative 
function shown below:
$$ \begin{cases} 
      \frac{1}{2}x & x \texttt{ is even} \\
      3x + 1 & x \texttt{ is odd} 
   \end{cases}
$$
Lothar Collatz proposed that this sequence will always converge to $1$ starting 
from an arbitrary positive integer. Given a starting integer, the following 
program returns a list of iterations that ends in 1. The program hence uses $1$ 
as its base case even though it hasn't been mathematically proven that all 
numbers will eventually reach this case, but we believe in Lothar.
\begin{lstlisting}[language=rippl]
collatz :: int -> [int]
collatz n =
    let rec_collatz n list =
        if n == 1
            then 1 cons list
        else if n % 2 == 0
            then rec_collatz (n / 2) (n cons list)
            else rec_collatz (3*n +1) (n cons list)
    in rec_collatz n []
\end{lstlisting}
\subsection{Weak Prime Number Theorem}
Bertrand's Postulate stated in the Weak Prime Number Theorem that there is 
always a prime number to be found between some $n$ and its double $2n$. This 
postulate was later proven by Pafnuty Chebyshev and refined by Paul Erd\"{o}s. 
The following program includes a function that determines the primality of a 
number and a function that takes a $n$ and returns the first prime between 
$n$ and $2n$.
\begin{lstlisting}[language=rippl]
is_prime :: int -> bool
is_prime n =
    let max = n / 2 in
    let range = [2...max] in
    let divisors = [x | x over range, n % x == 0] in
    len divisors == 0
    
prime_number_theorem :: int -> int
prime_number_theorem n =
    let range = [(n+1)...2*n] in
    let odd_range = [x | x over range, x % 2 != 0 ] in
    foldl (fun prev -> fun curr -> if is_prime then prev else curr)
        (head odd_range) odd_range
\end{lstlisting}
\subsection{Entrypoint and IO}
This program demonstrates how a main method would be written to take in a user-inputted number and print out the full list of iterations generated by the formula in the Collatz Conjecture.
\begin{lstlisting}[language=rippl]
main :: int -> [int]
main n = collatz n      # 10 -> [10,5,16,8,4,2,1]
\end{lstlisting}
\end{document}
